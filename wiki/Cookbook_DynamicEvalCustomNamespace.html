<div id="contentbox">
 <div class="widget">
  <p />
<h2>
  <a name="Evaluating_Code_in_a_Custom_Name"> Evaluating Code in a Custom Namespace </a>
</h2>
<p />
<h3>
  <a name="Problem"> Problem </a>
</h3>
<p />
You want to <code>eval</code> code that:
<p />
<ul>
<li> Doesn't have access to anything declared or loaded by the code that calls <code>eval</code>
</li>
<li> Does have access to certain modules you choose to allow it access to
</li>
</ul>
<p />
And all this without the code you are evaluating having to include <code>require</code> statements to load the modules it needs.
<p />
<h3>
  <a name="Solution"> Solution </a>
</h3>
<p />
All code is evaluated within a <code>namespace</code>.  You must firstly create a new empty <code>namespace</code> for the code you wish to <code>eval</code>, and then attach any necessary modules to it:
<p />
<div class="scheme">
  <pre>(<span class="keyword">define</span> <span class="variable">new-namespace</span> (<span class="variable">make-namespace</span> <span class="keyword">'</span><span class="variable">initial</span>))
(<span class="variable">parameterize</span> ((<span class="variable">current-namespace</span> <span class="variable">new-namespace</span>))
  (<span class="variable">namespace-require</span> <span class="keyword">'</span>(<span class="variable">file</span> <span class="selfeval">"my-module.ss"</span>))
  (<span class="builtin">eval</span> <span class="variable">untrusted-code</span>))
</pre>
</div>
<p />
<h3>
  <a name="Discussion"> Discussion </a>
</h3>
<p />
Typically code evaluated in <code>eval</code> has access to anything visible to the code that calls <code>eval</code>.   E.g.:
<p />
<div class="scheme">
  <pre><span class="builtin">&gt;</span> (<span class="keyword">define</span> (<span class="variable">foo</span> <span class="variable">x</span>) (<span class="builtin">/</span> <span class="variable">x</span> <span class="selfeval">2</span>))
<span class="builtin">&gt;</span> (<span class="builtin">eval</span> <span class="keyword">'</span>(<span class="variable">foo</span> <span class="selfeval">2</span>))
<span class="selfeval">1</span>
</pre>
</div>
<p />
This is insecure -- the evaluated code could mess with the internals of the code that evaluates it. [TODO]
<p />
This is useful, for example, when web pages.  Say you have a library of code that you use to write webpages (e.g. <a href="/Cookbook/SSAX">SSAX</a> or <a href="/Cookbook/WebIt">WebIt</a> and some transformations to HTML).  You want to write the webpages as Scheme programs but you want to put each page in its own file and you don't want to worry about all the usual <code>module</code> wrapper code to load your library.  You can use this method to create a custom namespace that includes your library and <code>eval</code> the code in this namespace.
<p />
[TODO: talk about attaching modules from existing namespace]
<p />
See also <a href="/Cookbook/DynamicUntrustedEval">DynamicUntrustedEval</a>
<p />
<p />
Here is another example of attaching modules from an existing namespace:
<p />
<div class="scheme">
  <pre>(<span class="keyword">module</span> <span class="variable">point</span> <span class="variable">mzscheme</span>
  (<span class="keyword">define-struct</span> <span class="variable">point</span> (<span class="variable">x</span> <span class="variable">y</span>))
  (<span class="keyword">provide</span> (<span class="variable">struct</span> <span class="variable">point</span> (<span class="variable">x</span> <span class="variable">y</span>)))
  (<span class="variable">printf</span> <span class="selfeval">"point.ss is invoked~n"</span>))
(<span class="keyword">module</span> <span class="variable">evaluation</span> <span class="variable">mzscheme</span>
  (<span class="keyword">define</span> (<span class="variable">module-path-&gt;symbol</span> <span class="variable">module-path</span>)
    ((<span class="variable">current-module-name-resolver</span>) <span class="variable">module-path</span> <span class="selfeval">#f</span> <span class="selfeval">#f</span>))
  (<span class="keyword">define</span> (<span class="variable">make-evaluation-namespace</span>)
    (<span class="keyword">let</span> ([<span class="variable">ns</span> (<span class="variable">make-namespace</span>)]
          [<span class="variable">main-ns</span> (<span class="variable">current-namespace</span>)]
          [<span class="variable">path</span> (<span class="variable">module-path-&gt;symbol</span> <span class="selfeval">"point.ss"</span>)])
      (<span class="variable">parameterize</span> ([<span class="variable">current-namespace</span> <span class="variable">ns</span>])
        (<span class="variable">namespace-attach-module</span> <span class="variable">main-ns</span> <span class="variable">path</span>)
        <span class="variable">ns</span>)))
  (<span class="keyword">provide</span> <span class="variable">evaluate</span>)
  (<span class="keyword">define</span> (<span class="variable">evaluate</span> <span class="variable">module-stx</span>)
    (<span class="keyword">syntax-case</span> <span class="variable">module-stx</span> ()
      [(<span class="keyword">module</span> <span class="variable">module-name</span> <span class="variable">language</span> <span class="variable">body</span> ...)
       (<span class="variable">parameterize</span> ([<span class="variable">current-namespace</span> (<span class="variable">make-evaluation-namespace</span>)])
         (<span class="variable">eval-syntax</span> <span class="variable">module-stx</span>)
         (<span class="variable">eval-syntax</span> <span class="selfeval">#</span><span class="keyword">`</span>(<span class="keyword">require</span> <span class="variable">module-name</span>))
         (<span class="variable">namespace-variable-value</span> <span class="keyword">'</span><span class="variable">result</span>))])))
(<span class="keyword">module</span> <span class="variable">test-evaluation</span> <span class="variable">mzscheme</span>
  (<span class="keyword">require</span> <span class="selfeval">"evaluation.ss"</span>
           <span class="selfeval">"point.ss"</span>)
  (<span class="keyword">define</span> <span class="variable">my-point</span>
    (<span class="variable">evaluate</span> <span class="selfeval">#</span><span class="keyword">'</span>(<span class="keyword">module</span> <span class="variable">a</span> <span class="variable">mzscheme</span>
                  (<span class="keyword">require</span> <span class="selfeval">"point.ss"</span>)
                  (<span class="keyword">provide</span> <span class="variable">result</span>)
                  (<span class="keyword">define</span> <span class="variable">result</span> (<span class="variable">make-point</span> <span class="selfeval">3</span> <span class="selfeval">4</span>)))))
  (<span class="variable">printf</span> <span class="selfeval">"The point I made is: (~a ~a)~n"</span>
          (<span class="variable">point-x</span> <span class="variable">my-point</span>) (<span class="variable">point-y</span> <span class="variable">my-point</span>)))
</pre>
</div>
<p />
We take special care here to make sure that the point module is shared between the main namespace and the evaluated code's namespaces.
If we don't use <strong>namespace-attach-module</strong>, then <strong>test-evaluation</strong> can't call any of the point's selector functions since the evaluated code will instantiate its own point structure.
<p />
Also note that the call to module-path-&gt;symbol needs to occur outside the context of the evaluated code's namespace; <strong>(current-module-name-resolver)</strong> can load modules if they don't yet exist in a namespace, and that's precisely what we're trying to avoid.
<p />
<p />
<p />
<hr>
<p />
<p />
<h3>
  <a name="Comments_about_this_recipe"> Comments about this recipe </a>
</h3>
<p />
Here's an <code>eval</code> that hides the <code>set!</code> form:
<p />
<div class="scheme">
  <pre>(<span class="keyword">define</span> (<span class="variable">my-eval</span> <span class="variable">sxp</span>)
  (<span class="keyword">define</span> <span class="variable">owner-ns</span> (<span class="variable">current-namespace</span>))
  (<span class="variable">parameterize</span> ([<span class="variable">current-namespace</span> (<span class="variable">make-namespace</span> <span class="keyword">'</span><span class="variable">empty</span>)])
    (<span class="variable">namespace-attach-module</span> <span class="variable">owner-ns</span> <span class="keyword">'</span><span class="variable">mzscheme</span>)
    (<span class="variable">namespace-require</span> <span class="keyword">'</span>(<span class="variable">all-except</span> <span class="variable">mzscheme</span> <span class="keyword">set!</span>))
    (<span class="builtin">eval</span> <span class="variable">sxp</span>)))
</pre>
</div>
<p />
So if you try to bang on an identifier, you get an error:
<p />
<div class="scheme">
  <pre><span class="builtin">&gt;</span>  (<span class="variable">my-eval</span> <span class="keyword">'</span>(<span class="keyword">begin</span> (<span class="keyword">define</span> <span class="variable">x</span> <span class="selfeval">2</span>) (<span class="keyword">set!</span> <span class="variable">x</span> <span class="selfeval">3</span>) <span class="variable">x</span>))
<span class="variable">reference</span> <span class="variable">to</span> <span class="variable">undefined</span> <span class="variable">identifier:</span> <span class="keyword">set!</span>
</pre>
</div>
<p />
Note that <code>namespace-attach-module</code> only registers an instantiated module in the module registry of a destination namespace.  It doesn't actually import any symbols as the (require ...) form does -- for that you need to <code>namespace-require</code> the registered module.
<p />
To instantiate a module that you haven't required in the source namespace, use dynamic-require.  For example, if you have a module <code>foo</code> in foo.ss:
<p />
<div class="scheme">
  <pre><span class="comment">;; foo.ss
</span>(<span class="keyword">module</span> <span class="variable">foo</span> <span class="variable">mzscheme</span>
 (<span class="variable">printf</span> <span class="selfeval">"Instantiated foo!~n"</span>))
</pre>
</div>
<p />
To provide foo.ss to your users, change your <code>my-eval</code> to instantiate it:
<p />
<div class="scheme">
  <pre>(<span class="keyword">define</span> (<span class="variable">my-eval2</span> <span class="variable">sxp</span>)
  (<span class="keyword">define</span> <span class="variable">owner-ns</span> (<span class="variable">current-namespace</span>))
  (<span class="keyword">define</span> <span class="variable">foo-module-path</span> ((<span class="variable">current-module-name-resolver</span>) <span class="selfeval">"foo.ss"</span>
                                                          <span class="selfeval">#f</span> <span class="selfeval">#f</span>))
  <span class="comment">;; Now instantiate foo in the source so we can attach it:
</span>  (<span class="variable">dynamic-require</span> <span class="variable">bah-module-path</span> <span class="selfeval">#f</span>)
  <span class="comment">;; Continue as before:
</span>  (<span class="variable">parameterize</span> ([<span class="variable">current-namespace</span> (<span class="variable">make-namespace</span> <span class="keyword">'</span><span class="variable">empty</span>)])
    (<span class="variable">namespace-attach-module</span> <span class="variable">owner-ns</span> <span class="keyword">'</span><span class="variable">mzscheme</span>)
    (<span class="variable">namespace-require</span> <span class="keyword">'</span>(<span class="variable">all-except</span> <span class="variable">mzscheme</span> <span class="keyword">set!</span>))
    (<span class="variable">namespace-attach-module</span> <span class="variable">owner-ns</span> <span class="variable">foo-module-path</span>)
    (<span class="variable">namespace-require</span> <span class="keyword">'</span><span class="selfeval">"foo.ss"</span>)
    (<span class="builtin">eval</span> <span class="variable">sxp</span>)))
</pre>
</div>
<p />
Remember that modules are only instantiated once per namespace, so you'll only see foo's load-time output one time:
<p />
<div class="scheme">
  <pre><span class="builtin">&gt;</span> (<span class="variable">my-eval2</span> <span class="keyword">'</span><span class="selfeval">1</span>)
<span class="variable">Instantiated</span> <span class="variable">foo!</span>
<span class="selfeval">1</span>
<span class="builtin">&gt;</span> (<span class="variable">my-eval2</span> <span class="keyword">'</span><span class="selfeval">1</span>)
<span class="selfeval">1</span>
</pre>
</div>
<p />
-- <a href="/Main/DanielSilva">DanielSilva</a> - 25 Jan 2005
<p />
<h3>
  <a name="Contributors"> Contributors </a>
</h3>
<p />
-- <a href="/Main/NoelWelsh">NoelWelsh</a> - 20 Jan 2005
  <p />
<table border="1" cellspacing="0" cellpadding="0">
   <tr>
  <th colspan="2" align="center" bgcolor="#99CCCC"> <a href="/Cookbook/CookbookForm">CookbookForm</a> </th>
</tr>
<tr>
  <th bgcolor="#99CCCC" align="right"> <a href="/Cookbook/TopicType">TopicType</a>:</th>
  <td align="left"> Recipe </td>
</tr>
<tr>
  <th bgcolor="#99CCCC" align="right"> <a href="/Cookbook/ParentTopic">ParentTopic</a>:</th>
  <td align="left"> <a href="/Cookbook/DynamicRecipes">DynamicRecipes</a> </td>
</tr>
<tr>
  <th bgcolor="#99CCCC" align="right"> <a href="/Cookbook/TopicOrder">TopicOrder</a>:</th>
  <td align="left"> 999 </td>
</tr>
</table>
<p />
 </div>
</div>
