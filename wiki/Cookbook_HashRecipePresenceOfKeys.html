<div id="contentbox">
 <div class="widget">
  <p />
<h2>
  <a name="Testing_for_the_Presence_of_a_Ke"> Testing for the Presence of a Key in a Hash </a>
</h2>
<p />
<h3>
  <a name="Problem"> Problem </a>
</h3>
<p />
You need to know wheter a hash has a particular key, regardless of
whatever value may be associated with a key.
<p />
<h3>
  <a name="Solution"> Solution </a>
</h3>
<p />
The procedure <code>hash-table-get</code> returns the value associated
to a key in the hash table.  If no value is found it returns
the application of its failure-thunk (the third, optional
argument).  So to check if a hash table contains a
particular key we must arrange the failure-thunk to return a
value that cannot possibly be held in the hash table.  If
<code>hash-table-get</code> returns this value we know the hash table
does not contain the key.
<p />
How can the failure-thunk guarantee that the value it
returns will no be in the hash table?  The secret is to use
an uninterned symbol, which is a symbol that is guaranteed
not <code>eq?</code>, <code>eqv?</code>, or <code>equal?</code> to any other symbol.  Most
Schemes, including <a href="/Cookbook/PltScheme">PltScheme</a>, provide the function <code>gensym</code>
to generate uninterned symbols.
<p />
So we can use the function <code>hash-has-key?</code> below to test for the presence of a key:
<p />
<div class="scheme">
  <pre>(<span class="keyword">define</span> <span class="variable">hash-has-key?</span>
  (<span class="keyword">let</span> ((<span class="variable">symbol</span> (<span class="variable">gensym</span>)))
    (<span class="keyword">lambda</span> (<span class="variable">table</span> <span class="variable">key</span>)
      (<span class="builtin">not</span> (<span class="builtin">eq?</span> (<span class="variable">hash-table-get</span> <span class="variable">table</span> <span class="variable">key</span> (<span class="keyword">lambda</span> () <span class="variable">symbol</span>)) <span class="variable">symbol</span>)))))
</pre>
</div>
<p />
An example of its use:
<p />
<div class="scheme">
  <pre><span class="builtin">&gt;</span> (<span class="keyword">define</span> <span class="variable">hash</span> (<span class="variable">make-hash-table</span>))
<span class="builtin">&gt;</span> (<span class="variable">hash-has-key?</span> <span class="variable">hash</span> <span class="keyword">'</span><span class="variable">foo</span>)
<span class="selfeval">#f</span>
<span class="builtin">&gt;</span> (<span class="variable">hash-table-put!</span> <span class="variable">hash</span> <span class="keyword">'</span><span class="variable">foo</span> <span class="selfeval">1</span>)
<span class="builtin">&gt;</span> (<span class="variable">hash-has-key?</span> <span class="variable">hash</span> <span class="keyword">'</span><span class="variable">foo</span>)
<span class="selfeval">#t</span>
</pre>
</div>
<p />
<h3>
  <a name="Discussion"> Discussion </a>
</h3>
<p />
The definition of <code>hash-has-key?</code> above uses
<a href="/Cookbook/IdiomStaticVariables">IdiomStaticVariables</a> to avoid creating the unique symbol
more than once.
<p />
It is important that we use an uninterned symbol to check
for the absence of the key as <a href="/Cookbook/PltScheme">PltScheme</a> allows any value,
including <code>#f</code> and <code>void</code>, to be stored as the value with a
hash table.
<p />
In addition to <code>gensym</code>, <a href="/Cookbook/PltScheme">PltScheme</a> provides the function
<code>string-&gt;uninterned-symbol</code> which is like <code>symbol-&gt;string</code>
except the symbol is uninterned.  This means that two
symbols created with <code>string-&gt;uninterned-symbol</code> could
<code>display</code> the same but in fact not be <code>eq?</code>, <code>eqv?</code>, or
<code>equal?</code>
<p />
If <code>gensym</code> was not available we could take use of the fact
that <code>eq?</code> returns <code>#f</code> is its two arguments represent
different values in the store (in other words are allocated
at different addresses) and <code>list</code> is guaranteed to return a
new allocated list.  So we could write <code>hash-has-key?</code> as:
<p />
<div class="scheme">
  <pre>(<span class="keyword">define</span> <span class="variable">hash-has-key?</span>
  (<span class="keyword">let</span> ((<span class="variable">dummy</span> (<span class="builtin">list</span> <span class="keyword">'</span><span class="global">*no-such-element*</span>)))
    (<span class="keyword">lambda</span> (<span class="variable">table</span> <span class="variable">key</span>)
      (<span class="builtin">not</span> (<span class="builtin">eq?</span> <span class="variable">dummy</span>
                (<span class="variable">hash-table-get</span> <span class="variable">table</span>
                                <span class="variable">key</span>
                                (<span class="keyword">lambda</span> () <span class="variable">dummy</span>)))))))
</pre>
</div>
<p />
There is a company called Gensym.  There primary product is
a Lisp based Expert System shell.  Now you know where their
name comes from!
<p />
<p />
<hr>
<p />
<h3>
  <a name="Contributors"> Contributors </a>
</h3>
<p />
-- <a href="/Main/KarlaRamirez">KarlaRamirez</a> - 19 May 2004
-- <a href="/Main/AshInn">AshInn</a>
-- <a href="/Main/NoelWelsh">NoelWelsh</a> - 14 Sep 2004
-- <a href="/Main/JensAxelSoegaard">JensAxelSoegaard</a> - 15 Sep 2004
-- <a href="/Main/BrianJ">BrianJ</a> - 11 Dec 2006
<p />
<p />
<h3>
  <a name="Comments_about_this_recipe"> Comments about this recipe </a>
</h3>
<p />
I don't understand the comment:
<p />
  "However this is not guaranteed to work; it is possible that an
  advanced Scheme compiler could allocate two identical lists to the same object.".
<p />
A call to <code>list</code> is guaranteed by R5RS to return a <code>newly</code> allocated list.
The <code>eq?</code> test for object identity should work everywhere.
<p />
-- <a href="/Main/JensAxelSoegaard">JensAxelSoegaard</a> - 14 Sep 2004
<p />
You are correct.  However <code>eq?</code> is not guaranteed to return <code>#f</code> in, for example, <code>(eq? (list 1 2) (list 1 2))</code>.  I shall modify the recipe accordingly.  Thanks.  -- <a href="/Main/NoelWelsh">NoelWelsh</a> - 15 Sep 2004
<p />
<p />
Are you sure? The entry on <code>eq?</code> says that one should look under <code>eqv?</code>. And there it says:
<pre>
The eqv? procedure returns #t if:
   * obj1 and obj2 are pairs, vectors, or strings that denote the same
     locations in the store (section 3.4).
The eqv? procedure returns #f if:
   * obj1 and obj2 are pairs, vectors, or strings that denote distinct locations.
</pre>
<p />
The example  <code>(eq? '(a) '(a)) ==&gt;&nbsp; unspecified</code> illustrates that literals can be
coalesced by the compiler, but in this case we are making new pairs.
<p />
-- <a href="/Main/JensAxelSoegaard">JensAxelSoegaard</a> - 15 Sep 2004
<p />
I have been schooled! :-)
<p />
-- <a href="/Main/NoelWelsh">NoelWelsh</a>
<p />
Alternative implementations:
<p />
<div class="scheme">
  <pre>(<span class="keyword">define</span> <span class="variable">hash-has-key?</span>
  (<span class="keyword">let</span> ([<span class="variable">secret</span> (<span class="variable">let-struct</span> <span class="variable">secret</span> ()
                  (<span class="variable">make-secret</span>))])
    (<span class="keyword">lambda</span> (<span class="variable">table</span> <span class="variable">key</span>)
      (<span class="builtin">not</span> (<span class="builtin">eq?</span> (<span class="variable">hash-table-get</span> <span class="variable">table</span> <span class="variable">key</span> (<span class="keyword">lambda</span> () <span class="variable">secret</span>)) <span class="variable">secret</span>)))))
</pre>
</div>
<p />
or an arguably more readable solution:
<p />
<div class="scheme">
  <pre>(<span class="keyword">define</span> (<span class="variable">hash-has-key?</span> <span class="variable">table</span> <span class="variable">key</span>)
  (<span class="keyword">with-handlers</span> ([<span class="variable">exn:fail:contract?</span> (<span class="keyword">lambda</span> (<span class="variable">exn</span>) <span class="selfeval">#f</span>)])
    (<span class="variable">hash-table-get</span> <span class="variable">table</span> <span class="variable">key</span>)
    <span class="selfeval">#t</span>))
</pre>
</div>
<p />
-- <a href="/Main/DaveHerman">DaveHerman</a> - 26 Feb 2006
<p />
Another alternate implementation:
<p />
<div class="scheme">
  <pre>(<span class="keyword">define</span> <span class="variable">hash-has-key?</span>
  (<span class="keyword">let*</span> ([<span class="variable">result</span> <span class="selfeval">#t</span>]
         [<span class="variable">fail-thunk</span> (<span class="keyword">lambda</span> () (<span class="keyword">set!</span> <span class="variable">result</span> <span class="selfeval">#f</span>))])
    (<span class="keyword">lambda</span> (<span class="variable">table</span> <span class="variable">key</span>)
      (<span class="variable">hash-table-get</span> <span class="variable">table</span> <span class="variable">key</span> <span class="variable">fail-thunk</span>)
      (<span class="keyword">begin0</span> <span class="variable">result</span> (<span class="keyword">set!</span> <span class="variable">result</span> <span class="selfeval">#t</span>)))))
</pre>
</div>
-- <a href="/Main/BrianJ">BrianJ</a> - 11 Dec 2006
  <p />
<table border="1" cellspacing="0" cellpadding="0">
   <tr>
  <th colspan="2" align="center" bgcolor="#99CCCC"> <a href="/Cookbook/CookbookForm">CookbookForm</a> </th>
</tr>
<tr>
  <th bgcolor="#99CCCC" align="right"> <a href="/Cookbook/TopicType">TopicType</a>:</th>
  <td align="left"> Recipe </td>
</tr>
<tr>
  <th bgcolor="#99CCCC" align="right"> <a href="/Cookbook/ParentTopic">ParentTopic</a>:</th>
  <td align="left"> <a href="/Cookbook/HashRecipes">HashRecipes</a> </td>
</tr>
<tr>
  <th bgcolor="#99CCCC" align="right"> <a href="/Cookbook/TopicOrder">TopicOrder</a>:</th>
  <td align="left"> 030 </td>
</tr>
</table>
<p />
 </div>
</div>
