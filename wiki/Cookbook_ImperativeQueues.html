<div id="contentbox">
 <div class="widget">
  <p />
<h2>
  <a name="Imperative_Queues"> Imperative Queues </a>
</h2>
<p />
<h3>
  <a name="Problem"> Problem </a>
</h3>
<p />
A queue is a first-in first-out memory. Objects can be stored one by one and can be extracted (or removed) one by one. Objects are extracted (or removed) in the same time order as they are stored. How to implement a queue with constant access time, i.e. independent of the length of the queue? (Compare this problem with that of recipe <a href="/Cookbook/FunctionalQueue">FunctionalQueue</a>).
<p />
<h3>
  <a name="Solution"> Solution </a>
</h3>
The solution shown in this recipe is in essence the same as described in section 3.3.2 of SICP. However, in this recipe the word 'pointer' is avoided. Each queue will have its own set of six procedures, say <code>queue-empty?</code>, <code>queue-enter!</code>, <code>queue-extract!</code>, <code>queue-peek</code>, <code>queue-remove!</code> and <code>queue-&gt;list</code>.
<p />
<ul>
<li> 1: <code>(queue-empty?&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; )</code> → #t if the queue is empty, else #f.
</li>
<li> 2: <code>(queue-enter!&nbsp; &nbsp; object)</code> → void, enters the object in the queue.
</li>
<li> 3: <code>(queue-extract! [thunk])</code> → removes an object from the queue and returns that object.
</li>
<li> 4: <code>(queue-peek &nbsp; &nbsp; [thunk])</code> → returns the next object of the queue without removing it.
</li>
<li> 5: <code>(queue-remove!&nbsp; [thunk])</code> → void, removes an object from the queue.
</li>
<li> 6: <code>(queue-&gt;list &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; )</code> → copy of the queue (a newly allocated immutable list with the same (<code>eq?</code>) contents as the queue)
</li>
</ul>
<p />
These six procedures share access to a freshly allocated queue. The queue can be accessed by means of these six procedures only. Every distinct queue has its own distinct set of six procedures. Initially the queue is empty. When the queue is empty, the procedures <code>queue-extract!</code>, <code>queue-peek</code> or <code>queue-remove!</code> return whatever is returned by the thunk or signal an error if no thunk is supplied. The procedures are prepared by means of procedure <code>make-queue</code>:
<p />
<code>(make-queue [string])</code> → multiple value of six procedures
<p />
The optional string is used in error messages in order to identify the queue. It has no other use. The default string is <code>"no name"</code>.
<p />
The internal representation for the queue is a mutable list containing the entered objects in the reversed order, i.e. the most recent one at the end and the oldest one at the start. Procedure <code>queue-enter!</code> appends an object at the end of the queue. This is done in situ (i.e. destructively) Procedures <code>queue-extract!</code>, <code>queue-peek</code> and <code>queue-remove!</code> apply to the first element of the queue. Procedures <code>queue-extract!</code> and <code>queue-remove!</code> replace the queue by its cdr, thus removing the oldest element. A simple, but inefficient implementation (without names, thunks or error-detection) is
<p />
<div class="scheme">
  <pre><span class="comment">; WARNING: this is an inefficient implementation
</span>
(<span class="keyword">define</span> (<span class="variable">make-queue</span>)
 (<span class="keyword">let</span> ((<span class="variable">queue</span> ()))
  (<span class="builtin">values</span>
   (<span class="keyword">lambda</span> () (<span class="builtin">null?</span> <span class="variable">queue</span>))             <span class="comment">; queue-empty?   in constant time.
</span>   (<span class="keyword">lambda</span> (<span class="variable">object</span>)                      <span class="comment">; queue-enter!   NOT in constant time
</span>    (<span class="keyword">let</span> ((<span class="variable">new-pair</span> (<span class="builtin">list</span> <span class="variable">object</span>)))      <span class="comment">; because of the use of procedure last-pair.
</span>     (<span class="keyword">if</span> (<span class="builtin">null?</span> <span class="variable">queue</span>)
      (<span class="keyword">set!</span> <span class="variable">queue</span> <span class="variable">new-pair</span>)
      (<span class="variable">set-mcdr!</span> (<span class="variable">last-pair</span> <span class="variable">queue</span>) <span class="variable">new-pair</span>)))) <span class="comment">; (last-pair is not required by R5RS)
</span>   (<span class="keyword">lambda</span> ()                            <span class="comment">; queue-extract! in constant time.
</span>    (<span class="keyword">let</span> ((<span class="variable">object</span> (<span class="variable">mcar</span> <span class="variable">queue</span>)))
     (<span class="keyword">set!</span> <span class="variable">queue</span> (<span class="variable">mcdr</span> <span class="variable">queue</span>)) <span class="variable">object</span>))
   (<span class="keyword">lambda</span> () (<span class="variable">mcar</span> <span class="variable">queue</span>))              <span class="comment">; queue-peek,    in constant time.
</span>   (<span class="keyword">lambda</span> () (<span class="keyword">set!</span> <span class="variable">queue</span> (<span class="variable">mcdr</span> <span class="variable">queue</span>))) <span class="comment">; queue-remove!  in constant time.
</span>   (<span class="keyword">lambda</span> () (<span class="variable">mlist-&gt;list</span> <span class="variable">queue</span>)))))    <span class="comment">; queue-&gt;list O(length of queue).
</span></pre>
</div>
<p />
In this implementation, procedure <code>queue-enter!</code> is inefficient, because it calls procedure <code>last-pair</code>, which does a full traversal of the queue. In order to avoid this traversal, the last pair must be memorized:
<p />
<div class="scheme">
  <pre>(<span class="keyword">define</span> (<span class="variable">make-queue</span>)
 (<span class="keyword">let</span> ((<span class="variable">queue</span> ()) (<span class="variable">last-pair</span> ()))        <span class="comment">; last-pair always is the last pair of the queue, except when the queue is empty.
</span>  (<span class="builtin">values</span>                                <span class="comment">; for an empty queue last-pair has no meaning. The initial value is arbitrarily choosen to be ()
</span>   (<span class="keyword">lambda</span> () (<span class="builtin">null?</span> <span class="variable">queue</span>))             <span class="comment">; queue-empty?   same as before.
</span>   (<span class="keyword">lambda</span> (<span class="variable">object</span>)                      <span class="comment">; queue-enter!   now in constant time indeed.
</span>    (<span class="keyword">let</span> ((<span class="variable">new-pair</span> (<span class="variable">mlist</span> <span class="variable">object</span>)))
     (<span class="keyword">if</span> (<span class="builtin">null?</span> <span class="variable">queue</span>)
      (<span class="keyword">set!</span> <span class="variable">queue</span> <span class="variable">new-pair</span>)
      (<span class="variable">set-mcdr!</span> <span class="variable">last-pair</span> <span class="variable">new-pair</span>))
     (<span class="keyword">set!</span> <span class="variable">last-pair</span> <span class="variable">new-pair</span>)))
   (<span class="keyword">lambda</span> ()                            <span class="comment">; queue-extract! same as before.
</span>    (<span class="keyword">let</span> ((<span class="variable">object</span> (<span class="variable">mcar</span> <span class="variable">queue</span>)))
     (<span class="keyword">set!</span> <span class="variable">queue</span> (<span class="variable">mcdr</span> <span class="variable">queue</span>)) <span class="variable">object</span>))
   (<span class="keyword">lambda</span> () (<span class="variable">mcar</span> <span class="variable">queue</span>))              <span class="comment">; queue-peek,    same as before.
</span>   (<span class="keyword">lambda</span> () (<span class="keyword">set!</span> <span class="variable">queue</span> (<span class="variable">mcdr</span> <span class="variable">queue</span>))) <span class="comment">; queue-remove!  same as before.
</span>   (<span class="keyword">lambda</span> () (<span class="variable">mlist-&gt;list</span> <span class="variable">queue</span>)))))    <span class="comment">; queue-&gt;list    same as before.
</span></pre>
</div>
<p />
Example of use:
<p />
<div class="scheme">
  <pre>(<span class="variable">define-values</span>
 (<span class="variable">queue-empty?</span> <span class="variable">queue-enter!</span> <span class="variable">queue-extract!</span> <span class="variable">queue-peek</span> <span class="variable">queue-remove!</span> <span class="variable">queue-&gt;list</span>)
 (<span class="variable">make-queue</span>))
<span class="comment">; operation            new-queue       new-last-pair
</span><span class="comment">;                      ()              ()
</span>(<span class="variable">enter!</span> <span class="selfeval">1</span>) <span class="comment">; --&gt; void, {1)             {1}
</span>(<span class="variable">enter!</span> <span class="selfeval">2</span>) <span class="comment">; --&gt; void, {1 2}           {2}
</span>(<span class="variable">enter!</span> <span class="selfeval">3</span>) <span class="comment">; --&gt; void, {1 2 3}         {3}
</span>(<span class="variable">extract!</span>) <span class="comment">; --&gt; 1   , {2 3}           {3}
</span>(<span class="variable">enter!</span> <span class="selfeval">4</span>) <span class="comment">; --&gt; void, {2 3 4}         {4}
</span>(<span class="variable">extract!</span>) <span class="comment">; --&gt; 2   , {3 4}           {4}
</span>(<span class="variable">extract!</span>) <span class="comment">; --&gt; 3   , {4}             {4}
</span>(<span class="variable">extract!</span>) <span class="comment">; --&gt; 4   , ()              ()
</span></pre>
</div>
<p />
Now it is a matter of routine in order to prepare the full implemention, name, thunk arguments and error detection included:
<p />
<div class="scheme">
  <pre>(<span class="keyword">module</span> <span class="variable">queues</span> <span class="variable">mzscheme</span> (<span class="keyword">provide</span> <span class="variable">make-queue</span>)
 (<span class="keyword">define</span> <span class="variable">make-queue</span>
  (<span class="variable">case-lambda</span>
   (() (<span class="variable">make-queue</span> <span class="selfeval">"no name"</span>))
   ((<span class="variable">queue-name</span>)
    (<span class="keyword">if</span> (<span class="builtin">not</span> (<span class="builtin">string?</span> <span class="variable">queue-name</span>))
     (<span class="variable">raise-type-error</span> <span class="keyword">'</span><span class="variable">make-queue</span> <span class="selfeval">"string"</span> <span class="variable">queue-name</span>)
     (<span class="keyword">let</span>              <span class="comment">; local state variables
</span>      ((<span class="variable">queue</span> ())      <span class="comment">; the queue proper
</span>       (<span class="variable">last-pair</span> ())) <span class="comment">; always the last pair of the queue
</span>
      (<span class="keyword">define</span> (<span class="variable">queue-empty?</span>) (<span class="builtin">null?</span>       <span class="variable">queue</span>))
      (<span class="keyword">define</span> (<span class="variable">queue-peek</span>  ) (<span class="variable">mcar</span>        <span class="variable">queue</span>))
      (<span class="keyword">define</span> (<span class="variable">queue-&gt;list</span> ) (<span class="variable">mlist-&gt;list</span> <span class="variable">queue</span>))
      (<span class="keyword">define</span> (<span class="variable">queue-enter!</span> <span class="variable">object</span>)
       (<span class="keyword">let</span> ((<span class="variable">new-pair</span> (<span class="variable">mcons</span> <span class="variable">object</span> ())))
        (<span class="keyword">if</span> (<span class="variable">queue-empty?</span>)
         (<span class="keyword">set!</span> <span class="variable">queue</span> <span class="variable">new-pair</span>)
         (<span class="variable">set-mcdr!</span> <span class="variable">last-pair</span> <span class="variable">new-pair</span>))
        (<span class="keyword">set!</span> <span class="variable">last-pair</span> <span class="variable">new-pair</span>)))
      (<span class="keyword">define</span> (<span class="variable">queue-extract!</span>)
       (<span class="keyword">let</span> ((<span class="variable">entry</span> (<span class="variable">queue-peek</span>))) (<span class="variable">queue-remove!</span>) <span class="variable">entry</span>))
      (<span class="keyword">define</span> (<span class="variable">queue-remove!</span>)
       (<span class="keyword">set!</span> <span class="variable">queue</span> (<span class="variable">mcdr</span> <span class="variable">queue</span>))
       (<span class="keyword">if</span> (<span class="variable">queue-empty?</span>) (<span class="keyword">set!</span> <span class="variable">last-pair</span> ())))
      (<span class="keyword">define</span> (<span class="variable">make-proc-with-default</span> <span class="variable">proc</span> <span class="variable">proc-name</span>)
       <span class="comment">; accepts a procedure of no arguments and returns a procedure
</span>       <span class="comment">; accepting an optional thunk, calling this thunk (or raising
</span>       <span class="comment">; an error if no thunk is given) if the queue is empty. If the
</span>       <span class="comment">; queue is not empty, the proc is called.
</span>       (<span class="keyword">letrec</span>
        ((<span class="variable">default</span> (<span class="keyword">lambda</span> () (<span class="variable">empty-queue-error</span> <span class="variable">proc-name</span> <span class="variable">queue-name</span>)))
         (<span class="variable">new-proc</span>
          (<span class="variable">case-lambda</span>
           (() (<span class="variable">new-proc</span> <span class="variable">default</span>))
           ((<span class="variable">thunk</span>)
            (<span class="keyword">cond</span>
             ((<span class="builtin">not</span> (<span class="builtin">procedure?</span> <span class="variable">thunk</span>))
              (<span class="variable">raise-type-error</span> <span class="keyword">'</span><span class="variable">proc-name</span> <span class="selfeval">"thunk"</span> <span class="variable">thunk</span>))
             ((<span class="builtin">not</span> (<span class="variable">procedure-arity-includes?</span> <span class="variable">thunk</span> <span class="selfeval">0</span>))
              (<span class="variable">raise-type-error</span> <span class="variable">proc-name</span>
               <span class="selfeval">"procedure accepting no arguments"</span> <span class="variable">thunk</span>))
             ((<span class="variable">queue-empty?</span>) (<span class="variable">thunk</span>))
             (<span class="keyword">else</span> (<span class="variable">proc</span>)))))))
        <span class="variable">new-proc</span>))
      (<span class="keyword">let-syntax</span>
       ((<span class="variable">with-default</span> <span class="comment">; avoid double typing the proc-name
</span>         (<span class="keyword">syntax-rules</span> ()
          ((<span class="variable">with-default</span> <span class="variable">proc-name</span>)
           (<span class="variable">make-proc-with-default</span> <span class="variable">proc-name</span> <span class="keyword">'</span><span class="variable">proc-name</span>)))))
       (<span class="builtin">values</span>
        <span class="variable">queue-empty?</span>
        <span class="variable">queue-enter!</span>
        (<span class="variable">with-default</span> <span class="variable">queue-extract!</span>)
        (<span class="variable">with-default</span> <span class="variable">queue-peek</span>)
        (<span class="variable">with-default</span> <span class="variable">queue-remove!</span>)
        <span class="variable">queue-&gt;list</span>)))))))
 (<span class="keyword">define</span> (<span class="variable">empty-queue-error</span> <span class="variable">proc-name</span> <span class="variable">queue-name</span>)
  (<span class="variable">error</span>
   (<span class="builtin">string-append</span> <span class="selfeval">"queue-procedure "</span>
    (<span class="builtin">symbol-&gt;string</span> <span class="variable">proc-name</span>)
    <span class="selfeval">" applied to queue "</span><span class="variable">queue-name</span><span class="selfeval">" while being empty."</span>))))
</pre>
</div>
<p />
A good alternative is to implement the queues as a class of objects with two private variables <code>queue</code> and <code>last-pair</code> and methods <code>empty?</code>, <code>enter!</code>, <code>extract!</code>, <code>peek</code>, <code>remove!</code>, <code>queue-&gt;list</code> and <code>name</code>:
<p />
<div class="scheme">
  <pre>(<span class="keyword">module</span> <span class="variable">queues</span> <span class="variable">mzscheme</span>
 (<span class="keyword">provide</span> <span class="variable">queue%</span>)
 (<span class="keyword">require</span> (<span class="variable">lib</span> <span class="selfeval">"class.ss"</span>))
 (<span class="keyword">define</span> <span class="variable">queue%</span>
  (<span class="variable">class*</span> <span class="variable">object%</span>
   ((<span class="variable">interface</span> () <span class="variable">empty?</span> <span class="variable">enter!</span> <span class="variable">extract!</span> <span class="variable">remove!</span> <span class="variable">peek</span> <span class="variable">queue-&gt;list</span> <span class="variable">name</span>))
   (<span class="variable">public</span> <span class="variable">empty?</span> <span class="variable">enter!</span> <span class="variable">extract!</span> <span class="variable">remove!</span> <span class="variable">peek</span> <span class="variable">queue-&gt;list</span> <span class="variable">name</span>)
   <span class="comment">; name
</span>
   (<span class="variable">init</span> (<span class="variable">init-queue-name</span> <span class="selfeval">"no name"</span>))
   (<span class="keyword">define</span> <span class="variable">queue-name</span> <span class="selfeval">#f</span>)
   (<span class="keyword">if</span> (<span class="builtin">not</span> (<span class="builtin">string?</span> <span class="variable">init-queue-name</span>))
    (<span class="variable">raise-type-error</span> <span class="keyword">'</span>|<span class="variable">queue%</span> <span class="variable">constr</span>| <span class="selfeval">"string"</span><span class="variable">init-queue-name</span> )
    (<span class="keyword">set!</span> <span class="variable">queue-name</span> <span class="variable">init-queue-name</span>))
   <span class="comment">; local state
</span>
   (<span class="keyword">define</span> <span class="variable">queue</span> ())
   (<span class="keyword">define</span> <span class="variable">last-pair</span> ())
   <span class="comment">; internal methods
</span>
   (<span class="keyword">define</span> (    <span class="variable">peek-intern</span>) (<span class="variable">mcar</span> <span class="variable">queue</span>))
   (<span class="keyword">define</span> (<span class="variable">extract!-intern</span>) (<span class="keyword">let</span> ((<span class="variable">entry</span> (<span class="variable">peek-intern</span>))) (<span class="variable">remove!-intern</span>) <span class="variable">entry</span>))
   (<span class="keyword">define</span> ( <span class="variable">remove!-intern</span>) (<span class="keyword">set!</span> <span class="variable">queue</span> (<span class="variable">mcdr</span> <span class="variable">queue</span>)))
   <span class="comment">; methods
</span>
   (<span class="keyword">define-syntax</span> <span class="variable">give-default</span>
    (<span class="keyword">syntax-rules</span> ()
     ((<span class="variable">give-default</span> <span class="variable">proc</span> <span class="variable">proc-name</span>)
      (<span class="keyword">define</span> <span class="variable">proc-name</span>
       (<span class="variable">case-lambda</span>
        (() (<span class="variable">proc-name</span> (<span class="keyword">lambda</span> () (<span class="variable">empty-error</span> (<span class="builtin">symbol-&gt;string</span> <span class="keyword">'</span><span class="variable">proc-name</span>)))))
        ((<span class="variable">thunk</span>) (<span class="variable">call-internal-method</span> <span class="variable">proc</span> <span class="variable">thunk</span> <span class="keyword">'</span><span class="variable">proc-name</span>)))))))
   (<span class="keyword">define</span> (<span class="variable">name</span>) <span class="variable">queue-name</span>)
   (<span class="keyword">define</span> (<span class="variable">empty?</span>) (<span class="builtin">null?</span> <span class="variable">queue</span>))
   (<span class="keyword">define</span> (<span class="variable">queue-&gt;list</span>) (<span class="variable">mlist-&gt;list</span> <span class="variable">queue</span>))
   (<span class="variable">give-default</span> <span class="variable">extract!-intern</span> <span class="variable">extract!</span>)
   (<span class="variable">give-default</span>  <span class="variable">remove!-intern</span> <span class="variable">remove!</span> )
   (<span class="variable">give-default</span>     <span class="variable">peek-intern</span> <span class="variable">peek</span>    )
   (<span class="keyword">define</span> (<span class="variable">enter!</span> <span class="variable">item</span>)
    (<span class="keyword">let</span> ((<span class="variable">new-pair</span> (<span class="variable">mcons</span> <span class="variable">item</span> ())))
     (<span class="keyword">if</span> (<span class="variable">empty?</span>)
      (<span class="keyword">set!</span> <span class="variable">queue</span> <span class="variable">new-pair</span>)
      (<span class="variable">set-mcdr!</span> <span class="variable">last-pair</span> <span class="variable">new-pair</span>))
     (<span class="keyword">set!</span> <span class="variable">last-pair</span> <span class="variable">new-pair</span>)))
   <span class="comment">; auxiliary procedures
</span>
   (<span class="keyword">define</span> (<span class="variable">call-internal-method</span> <span class="variable">proc</span> <span class="variable">thunk</span> <span class="variable">proc-name</span>)
    (<span class="keyword">cond</span>
     ((<span class="builtin">not</span> (<span class="keyword">and</span> (<span class="builtin">procedure?</span> <span class="variable">thunk</span>) (<span class="variable">procedure-arity-includes?</span> <span class="variable">thunk</span> <span class="selfeval">0</span>)))
      (<span class="variable">raise-type-error</span> <span class="variable">proc-name</span> <span class="selfeval">"thunk"</span> <span class="variable">thunk</span>))
     ((<span class="builtin">null?</span> <span class="variable">queue</span>) (<span class="variable">thunk</span>))
     (<span class="keyword">else</span> (<span class="variable">proc</span>))))
   (<span class="keyword">define</span> (<span class="variable">empty-error</span> <span class="variable">method-name</span>)
    (<span class="variable">error</span>
     (<span class="builtin">string-append</span> <span class="selfeval">"class queue: method "</span> <span class="variable">method-name</span>
      <span class="selfeval">" applied to queue "</span> <span class="variable">queue-name</span> <span class="selfeval">" while the queue is empty."</span>)))
   (<span class="variable">super-new</span>))))
</pre>
</div>
<p />
<p />
<hr>
<p />
<h3>
  <a name="Comments_about_this_recipe"> Comments about this recipe </a>
</h3>
Very welcome.
Code adapted to <a href="/Cookbook/MzScheme">MzScheme</a> version 3.99.0.9. All code requires: (require scheme/mpair)
<a href="/Main/JosKoot">JosKoot</a> 09-01-2008
<p />
<h3>
  <a name="Contributors"> Contributors </a>
</h3>
<p />
-- <a href="/Main/JosKoot">JosKoot</a> - 11 October 2006
  <p />
<table border="1" cellspacing="0" cellpadding="0">
   <tr>
  <th colspan="2" align="center" bgcolor="#99CCCC"> <a href="/Cookbook/CookbookForm">CookbookForm</a> </th>
</tr>
<tr>
  <th bgcolor="#99CCCC" align="right"> <a href="/Cookbook/TopicType">TopicType</a>:</th>
  <td align="left"> Recipe </td>
</tr>
<tr>
  <th bgcolor="#99CCCC" align="right"> <a href="/Cookbook/ParentTopic">ParentTopic</a>:</th>
  <td align="left"> <a href="/Cookbook/DataStructureRecipes">DataStructureRecipes</a> </td>
</tr>
<tr>
  <th bgcolor="#99CCCC" align="right"> <a href="/Cookbook/TopicOrder">TopicOrder</a>:</th>
  <td align="left"> 999 </td>
</tr>
</table>
<p />
 </div>
</div>
