<div id="contentbox">
 <div class="widget">
  <p />
<h2>
  <a name="Coroutines"> Coroutines </a>
</h2>
<p />
<h3>
  <a name="Problem"> Problem </a>
</h3>
In some cases it is desirable to transform a procedure that returns a table (a list, vector or list of lists and so on) into a procedure that returns one element each time it is called. The reason may be that it is not beforehand known how many of the elements actually will be needed. Another reason may be that the table potentially is infinite. A trivial example is:
<p />
500 Can't connect to 127.0.0.1:8778 (connect: Connection refused)
<p />
<p />
Notice that <code>(define inf-counter (make-counter +inf.0))</code> produces an endless counter, although there are more elegant methods to construct such a counter.
<p />
In non trivial cases the problem of converting a list-producer into an element-by-element-producer is located in capturing the internal state of the list-producer in order to make known what has already been done and particularly what is still left to be done. In some cases one or more local variables may be sufficient (as in the case of the above counter), but in other cases, a more sophisticated method is required, particularly if the elements to be produced are interconnected by one or more levels of recursive relations. The most general method of capturing the internal state of a procedure is by capturing the continuation of the current stage of the computation. The procedure should 'replace itself' by this continuation right before returning each next element. Such a procedure is called a coroutine. Another approach is the use of streams. This approach is not treated in this recipe.
<p />
<h4>
  <a name="Rationale"> Rationale </a>
</h4>
Section 9.4 of <a href="http://www.cs.indiana.edu/eopl/" target="_top">EOPL</a> provides an excellent introduction into the concept of coroutines. This recipe is meant to be a simpler introduction by using a slightly different approach. Moreover the examples in this recipe are in PLT Scheme (<code>#lang scheme</code>) whereas those of EOPL are in EOPL's own language.
<p />
<h3>
  <a name="Solution"> Solution </a>
</h3>
A coroutine needs four things:
<p />
<ul>
<li> The procedure proper.
</li>
<li> A means to return a result to the caller of the coroutine while replacing the coroutine itself by its current continuation. This will be done by a procedure called <code>return</code>.
</li>
<li> Because procedure <code>return</code> must replace the coroutine by a continuation, the coroutine cq its continuation must be kept in a variable, say <code>entry</code>. We can update variables. Procedures can only be updated by changing their internal state. Variable <code>entry</code> is this internal state. The initial value of the <code>entry</code> is the procedure proper.
</li>
<li> Because the coroutine is not going to return normally, the continuation of its most recent call must be memorized. We use variable <code>exit</code>. (Later we will see that in fact one variable is enough for both the <code>entry</code> and the <code>exit</code>.)
</li>
</ul>
We start with a very simple example: a coroutine that returns the numbers 0, 1 and 2 and refuses to be called more than three times.
<p />
500 Can't connect to 127.0.0.1:8778 (connect: Connection refused)
<p />
<p />
The procedures <code>return</code> and <code>coroutine</code> resemble each other very much. In fact when we give procedure <code>coroutine</code> an argument, say <code>resume-value</code>, we have a perfect symmetry:
<p />
<table border="1" cellspacing="0" cellpadding="1"> <tr>
  <td>  variables  </td>
  <td>  procedures   </td>
  <td>  arguments       </td>
</tr>
<tr>
  <td>  <code>entry</code>    </td>
  <td>  <code>coroutine</code>  </td>
  <td>  <code>resume-value</code>  </td>
</tr>
<tr>
  <td>  <code>exit</code>     </td>
  <td>  <code>return</code>     </td>
  <td>  <code>return-value</code>  </td>
</tr>
</table>
<p />
500 Can't connect to 127.0.0.1:8778 (connect: Connection refused)
<p />
<p />
The arguments <code>first-resume-value</code> and <code>resume-value</code> are not used, but will appear to be useful in one of the examples to follow. Notice that always at least one of the variables <code>entry</code> and <code>exit</code> is outdated. When the coroutine is called, variable <code>exit</code> is updated, but the content of variable <code>entry</code> becomes obsolete as soon as the continuation it contains has been called. When the coroutine returns, variable <code>entry</code> is updated and the <code>exit</code> becomes obsolete immediately after being called. Hence we can use one shared variable for the entry and the exit. We shall call it <code>local-state</code>.
<p />
500 Can't connect to 127.0.0.1:8778 (connect: Connection refused)
<p />
<p />
Now the two procedures <code>return</code> and <code>coroutine</code> have become alpha-congruent. Hence we need only one of them. We shall call it <code>toggle</code>, because it toggles control between the caller of the coroutine and the coroutine itself.
<p />
500 Can't connect to 127.0.0.1:8778 (connect: Connection refused)
<p />
<p />
It is important that the procedure proper does not return normally. It must always return using procedure <code>toggle</code>. If the procedure proper would be allowed to return normally, control would be passed to the continuation of the first coroutine call probably leading to another call of the coroutine and possibly causing an infite loop. But there is a nicer way to finish. In most cases it is desirable that the procedure proper returns a special value indicating that it must no longer be called. Yet the coroutine must disable itself after finishing in order to prevent problems if by mistake the coroutine would be called after having expired. This will be done by procedure <code>finish</code>:
<p />
500 Can't connect to 127.0.0.1:8778 (connect: Connection refused)
<p />
<p />
Now it is time to prepare a procedure that given a proc-maker, id est a procedure that returns the procedure-proper, constructs a procedure that returns a coroutine-constr, i.e. a procedure that produces specimens of a certain species of coroutines.
<p />
<table border="1" cellspacing="0" cellpadding="1"> <tr>
  <td>  Procedure call                                 </td>
  <td>  Returned value(s)                   </td>
  <td>  Remarks                                                      </td>
</tr>
<tr>
  <td>  <code>(make-coroutine-constr proc-maker finisher)</code>  </td>
  <td>  -&gt; <code>coroutine-constr</code>               </td>
  <td>  &nbsp;  </td>
</tr>
<tr>
  <td>  <code>(proc-maker return finish constr-arg ...)</code>    </td>
  <td>  -&gt; <code>procedure-proper</code>               </td>
  <td>  the <code>constr-args</code> are those given to the coroutine-constr    </td>
</tr>
<tr>
  <td>  <code>(finisher last-return-value ...)</code>             </td>
  <td>  -&gt; <code>adapted-last-return-value ...</code>  </td>
  <td>  the <code>last-return-values</code> are those given to proceure finish  </td>
</tr>
<tr>
  <td>  <code>(procedure-proper first-resume-value ...)</code>    </td>
  <td>  -&gt; <code>any ...</code>                        </td>
  <td>  &nbsp;  </td>
</tr>
<tr>
  <td>  <code>(coroutine-constr constr-arg ...)</code>            </td>
  <td>  -&gt; <code>coroutine</code>                      </td>
  <td>  constructor-call                                             </td>
</tr>
<tr>
  <td>  <code>(return return-value ...)</code>                    </td>
  <td>  -&gt; <code>resume-value ...</code>               </td>
  <td>  return-call                                                  </td>
</tr>
<tr>
  <td>  <code>(finish last-return-value ...)</code>               </td>
  <td>  never returns                       </td>
  <td>  finish-call                                                  </td>
</tr>
<tr>
  <td>  <code>(coroutine resume-value ...)</code>                 </td>
  <td>  -&gt; <code>return-value ...</code>               </td>
  <td>  coroutine-call                                               </td>
</tr>
</table>
<p />
<p />
The proc-maker may require data to be processed, but it also requires the procedures <code>toggle</code> and <code>finish</code>. Therefore the proc-maker shall have the arguments <code>toggle</code> and <code>finish</code> possibly followed by more arguments for data that are provided during the construction of the coroutine. Procedure <code>make-coroutine-constr</code>, shown below, has been generalized for multiple resume and return values. A call to procedure <code>finish</code> is implied after normal return from the procedure proper, receiving the value(s) returned by the procedure proper. Procedure <code>make-coroutine-constr</code> takes two arguments, the procedure proper and a terminator. The latter is a procedure that is called by procedure <code>finish</code> with the last return values. Whatever is returned by the terminator is returned to the caller of the coroutine after the coroutine has disabled itself.
<p />
500 Can't connect to 127.0.0.1:8778 (connect: Connection refused)
<p />
<p />
A coroutine is too heavy a tool for a counter, but, for its simplicity, let's take a coroutine that conses a count to its resume-value. After a predetermined number of calls the coroutine expires while returning <code>#f</code>.
<p />
500 Can't connect to 127.0.0.1:8778 (connect: Connection refused)
<p />
<p />
Coroutines are not necessarily mortal, e.g. as produced by replacing (&gt;= i limit) by #f in the sixth line of the definition of <code>make-consing-counter</code>.
<p />
<h3>
  <a name="A_more_realistic_example_corouti"> A more realistic example: coroutines for permutations of lists. </a>
</h3>
This example also shows that coroutines may employ other coroutines, even those of their own species. We start from a list-producing version:
<p />
500 Can't connect to 127.0.0.1:8778 (connect: Connection refused)
<p />
<p />
The accumulated number of cycles of the loop of procedure <code>find-rotation</code> made during one cycle of the loop of procedure <code>list-permutations</code> usually is greater than the length of the list to be permuted. This is not optimal, of course. There are several ways to prevent unnecessary cycles, but they are not shown here, because this problem is not the subject of this recipe and because conversion of procedure <code>find-rotation</code> into a coroutine automatically prevents the rotator from making unnecessary cycles. Conversion into a coroutine:
<p />
500 Can't connect to 127.0.0.1:8778 (connect: Connection refused)
<p />
<p />
Procedure <code>list-permutations</code> (the list-producer) necessarily allocates separate storage for each permutation. So does the element by element producer <code>permute-aabc</code>. Procedures <code>make-permuter</code> and <code>make-rotator</code> can easily be adapted such as to do the permutations in situ (destructively) requiring less memory, less garbage collection and less processor time. However, only one permutation will be available at any given moment. Below procedure <code>make-rotator</code> is replaced by procedure <code>make-exchanger</code>, whose coroutines exchange the first element of the list to be permuted with one of the other elements (the first time with itself). Therefore the permutations may appear in another order. The list given to make-permuter must be mutable.
<p />
500 Can't connect to 127.0.0.1:8778 (connect: Connection refused)
<p />
<p />
The procedures made by <code>make-permuter</code> and <code>make-exchanger</code> do not return lists, because the list is always in variable <code>list-to-be-permuted</code>. They return <code>#t</code> as long as a new permutation cq. new exchange has been found and <code>#f</code> while expiring. As a test:
<p />
500 Can't connect to 127.0.0.1:8778 (connect: Connection refused)
<p />
<p />
<h3>
  <a name="When_a_coroutine_calls_a_continu"> When a coroutine calls a continuation of its caller or reversely  </a>
</h3>
When the procedure proper bypasses the toggler and calls a continuation pointing into the caller of the coroutine, contact between the coroutine and its caller is lost because the caller becomes part of the procedure proper. When the caller bypasses the toggler and calls a continuation pointing into the procedure proper, contact between the coroutine and its caller is lost because the procedure proper becomes part of the caller. All continuations always see the most recently stored local state. This state does not make explicit which one is supposed to have control, the caller or the coroutine. Contact can be reestablished though. E.g, if the procedure proper calls a continuation pointing into the caller, contact can be reestablished by making the caller call a continuation pointing into the procedure proper, assuming such a continuation has been made available to the caller.
<p />
<h3>
  <a name="If_a_procedure_proper_tries_to_c"> If a procedure proper tries to call the coroutine it belongs to  </a>
</h3>
If the procedure proper tries to call the coroutine it is part of, the toggler in fact returns control to the caller. Likewise, if the caller tries to call the returner of a coroutine, the toggler in fact returns control to the coroutine. Because this may lead to confusion and to errors that cannot easily be traced, it may be desirable to adapt procedure <code>make-coroutine-constr</code> such as to prohibit the procedure proper from calling the coroutine it belongs to and to prohibit the caller from calling the returner. This can be done in several ways, for instance by maintaining two separate procedures for the coroutine and its returner and adding a variable, say <code>control-state</code>, in which is recorded who is supposed to be in control, the caller or the coroutine. This does not prevent the procedure proper from being recursive.
<p />
500 Can't connect to 127.0.0.1:8778 (connect: Connection refused)
<p />
<p />
<p />
<hr>
<p />
<h3>
  <a name="Comments_about_this_recipe"> Comments about this recipe </a>
</h3>
Very welcome.
<p />
<h3>
  <a name="Contributors"> Contributors </a>
</h3>
<p />
-- <a href="/Main/JosKoot">JosKoot</a> - 27 Aug 2006, last update: April 22, 2009.
<p />
<h3>
  <a name="Source_code"> Source code </a>
</h3>
Last tested with : <a href="/Cookbook/DrScheme">DrScheme</a>, version 4.1.5.4-svn19apr2009 [3m].
<p />
All examples included in this recipe can be found in: <a href="http://schemecookbook.org/twiki/pub/Cookbook/CoRoutines/cookbookcoroutines.scm" target="_top">cookbookcoroutines.scm</a>:
<p />
<p />
<p />
  <p />
<table border="1" cellspacing="0" cellpadding="0">
   <tr>
  <th colspan="2" align="center" bgcolor="#99CCCC"> <a href="/Cookbook/CookbookForm">CookbookForm</a> </th>
</tr>
<tr>
  <th bgcolor="#99CCCC" align="right"> <a href="/Cookbook/TopicType">TopicType</a>:</th>
  <td align="left"> Recipe </td>
</tr>
<tr>
  <th bgcolor="#99CCCC" align="right"> <a href="/Cookbook/ParentTopic">ParentTopic</a>:</th>
  <td align="left"> <a href="/Cookbook/IdiomRecipes">IdiomRecipes</a> </td>
</tr>
<tr>
  <th bgcolor="#99CCCC" align="right"> <a href="/Cookbook/TopicOrder">TopicOrder</a>:</th>
  <td align="left"> 999 </td>
</tr>
</table>
  <p />
<table border="1" cellspacing="0" cellpadding="1"> <tr>
  <th align="center" bgcolor="#99CCCC"> <strong><a href="/TWiki/FileAttachment">Attachment</a>:</strong> </th>
  <th align="center" bgcolor="#99CCCC"> <strong>Action:</strong> </th>
  <th align="center" bgcolor="#99CCCC"> <strong>Size:</strong> </th>
  <th align="center" bgcolor="#99CCCC"> <strong>Date:</strong> </th>
  <th align="center" bgcolor="#99CCCC"> <strong>Who:</strong> </th>
  <th align="center" bgcolor="#99CCCC"> <strong>Comment:</strong> </th>
</tr>
<tr>
  <td>  <img src="/twiki/pub/icn/else.gif" width="16" height="16" align="top" alt=""> <a href="/twiki/pub/Cookbook/CoRoutines/cookbookcoroutines.scm">cookbookcoroutines.scm</a>     </td>
  <td>  <a href="http://schemecookbook.org/attach/Cookbook/CoRoutines?filename=cookbookcoroutines.scm&amp;amp;revInfo=1">action</a>     </td>
  <td>  13120  </td>
  <td>  21 Apr 2009 - 11:40  </td>
  <td>  <a href="/Main/JosKoot">JosKoot</a>  </td>
  <td>  &nbsp;  </td>
</tr>
</table>
<p />
 </div>
</div>
