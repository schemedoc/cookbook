<div id="contentbox">
 <div class="widget">
  <p />
<h2>
  <a name="How_to_Match_Struct_Fields_by_Na"> How to Match Struct Fields by Name </a>
</h2>
<p />
<h3>
  <a name="Problem"> Problem </a>
</h3>
<p />
Both pattern-matching libraries in PLT Scheme allow you to match against fields of a structure, but they only do so by position, as in the following example, in which <code>baz</code> is bound to the first field and <code>bar</code> to the second, despite the fact that the names are reversed:
<p />
<div class="scheme">
  <pre>(<span class="keyword">require</span> (<span class="variable">lib</span> <span class="selfeval">"plt-match.ss"</span>))
(<span class="keyword">define-struct</span> <span class="variable">foo</span> (<span class="variable">bar</span> <span class="variable">baz</span>))
(<span class="variable">match</span> (<span class="variable">make-foo</span> <span class="selfeval">3</span> <span class="selfeval">4</span>)
  [(<span class="variable">struct</span> <span class="variable">foo</span> (<span class="variable">baz</span> <span class="variable">bar</span>)) <span class="variable">bar</span>])
</pre>
</div>
<p />
Matching by position has two disadvantages.  First, it's sensitive to the order of the fields within the structure definition, and second, it requires you to include a pattern (even if it's only <code>_</code>) for each field in the structure, even if you only care about one of them (as above).
<p />
Sometimes it would be convenient to match and decompose a structure by field name, rather than field order.
<p />
<h3>
  <a name="Solution"> Solution </a>
</h3>
<p />
We can do this in <code>plt-match.ss</code>, using a combination of the <code>(? exp pat ...)</code> and <code>(app exp pat)</code> patterns.  Unfortunately, these aren't documented very thoroughly on the <code>plt-match.ss</code> page.
<p />
<ul>
<li> To match a value against a <code>(? exp pat ...)</code> clause, we evaluate <code>exp</code> to a unary function and apply it to the value.  If it returns a true value, then we match each remaining <code>pat</code> against the value.  (The <code>match.ss</code> help-desk page does describe this pattern in detail.)
</li>
</ul>
<p />
<ul>
<li> To match a value against an <code>(app exp pat)</code> clause, we evaluate <code>exp</code> to a unary function, apply it to the value, and match the result against <code>pat</code>.
</li>
</ul>
<p />
The following function demonstrates how to use these together to match by field name:
<p />
<div class="scheme">
  <pre><span class="comment">;; tested in PLT Scheme 300.3
</span>(<span class="keyword">require</span> (<span class="variable">lib</span> <span class="selfeval">"plt-match.ss"</span>))
(<span class="keyword">define-struct</span> <span class="variable">expr</span> (<span class="variable">srcloc</span>))
(<span class="keyword">define-struct</span> (<span class="variable">id</span> <span class="variable">expr</span>) (<span class="variable">name</span>))
(<span class="keyword">define-struct</span> (<span class="variable">lam</span> <span class="variable">expr</span>) (<span class="variable">arg</span> <span class="variable">body</span>))
(<span class="keyword">define-struct</span> (<span class="variable">app</span> <span class="variable">expr</span>) (<span class="variable">rator</span> <span class="variable">rand</span>))
<span class="comment">;; incomplete evaluator
</span>(<span class="keyword">define</span> (<span class="builtin">eval</span> <span class="variable">e</span> <span class="variable">r</span>)  <span class="comment">;; expr, environment (as alist)
</span>  (<span class="variable">match</span> <span class="variable">e</span>
    [(<span class="variable">?</span> <span class="variable">id?</span> (<span class="variable">app</span> <span class="variable">id-name</span> <span class="variable">name</span>))
     (<span class="builtin">cdr</span> (<span class="builtin">assq</span> <span class="variable">name</span> <span class="variable">r</span>))]
    [(<span class="variable">?</span> <span class="variable">app?</span> (<span class="variable">app</span> <span class="variable">app-rand</span> <span class="variable">rand</span>)
             (<span class="variable">app</span> <span class="variable">app-rator</span> (<span class="variable">?</span> <span class="variable">lam?</span> (<span class="variable">app</span> <span class="variable">lam-arg</span> <span class="variable">arg</span>)
                                    (<span class="variable">app</span> <span class="variable">lam-body</span> <span class="variable">body</span>))))
     (<span class="builtin">eval</span> <span class="variable">body</span> (<span class="builtin">cons</span> (<span class="builtin">cons</span> <span class="variable">arg</span> <span class="variable">rand</span>) <span class="variable">r</span>))]))
</pre>
</div>
<p />
This is part of an evaluator (as opposed to a partial evaluator!) for a simple expression language.  The AST nodes contain a <code>srcloc</code> field for source location information to use in error messages, but the evaluator doesn't care about this.
<p />
The first match clause checks to see if <code>e</code> is an <code>id</code>, applies the <code>id-name</code> selector to it, and binds the result to <code>name</code>.  Note that we have to check <code>id?</code> explicitly; otherwise, <code>id-name</code> will signal an error if <code>e</code> is an <code>app</code>.
<p />
The second match clause checks to see if <code>e</code> is an <code>app</code>.  If it is, it extracts its <code>rand</code> field with <code>app-rand</code> and its rator field with <code>app-rator</code>.  The <code>rator</code> field is then matched against a nested pattern that deconstructs the <code>lam</code> value, again by name rather than by position.
<p />
Neither match clause has to do anything with the <code>srcloc</code> field, despite it being the first field in all three structures.  Also,
the second clause matches the fields of the <code>app</code> structure out of order, just to show that this is possible.
<p />
<h3>
  <a name="Discussion"> Discussion </a>
</h3>
<p />
As far as I can tell, this is not possible with the <code>match.ss</code> library, as it doesn't have an equivalent to the <code>(app exp pat)</code> pattern form.
<p />
The syntax above is quite verbose and convoluted.  It'd be wonderful if someone could write a match-expander or a macro to clean this up, but my macro-fu and match-fu are, sadly, not sufficient to the task.
<p />
<hr>
<p />
Two follow-ups:
<p />
<noautolink>
<ol>
<li> This idiom is indeed possible with the <code>match.ss</code> library, but instead of writing <code>(app exp pat)</code>, one writes <code>( = exp pat)</code>.  (Forgive the space in front of the equals sign; it's required by the wiki's markup language.)
</li>
<li> I have learned enough macro-fu and match-fu to write a library to clean this idiom up.  See the <code>views.plt</code> package in PLaneT: <a href="http://planet.plt-scheme.org/300/#views.plt" target="_top">http://planet.plt-scheme.org/300/#views.plt</a> (for PLT Scheme v350 and later only).
</li>
</ol>
</noautolink>
<p />
-- <a href="/Main/RichardCobbe">RichardCobbe</a> - 03 Nov 2006
<p />
<p />
<hr>
<p />
<h3>
  <a name="Comments_about_this_recipe"> Comments about this recipe </a>
</h3>
<p />
<h3>
  <a name="Contributors"> Contributors </a>
</h3>
<p />
-- <a href="/Main/RichardCobbe">RichardCobbe</a> - 01 Jan 2006
  <p />
<table border="1" cellspacing="0" cellpadding="0">
   <tr>
  <th colspan="2" align="center" bgcolor="#99CCCC"> <a href="/Cookbook/CookbookForm">CookbookForm</a> </th>
</tr>
<tr>
  <th bgcolor="#99CCCC" align="right"> <a href="/Cookbook/TopicType">TopicType</a>:</th>
  <td align="left"> Recipe </td>
</tr>
<tr>
  <th bgcolor="#99CCCC" align="right"> <a href="/Cookbook/ParentTopic">ParentTopic</a>:</th>
  <td align="left"> <a href="/Cookbook/PatternMatchingRecipes">PatternMatchingRecipes</a> </td>
</tr>
<tr>
  <th bgcolor="#99CCCC" align="right"> <a href="/Cookbook/TopicOrder">TopicOrder</a>:</th>
  <td align="left">  </td>
</tr>
</table>
<p />
 </div>
</div>
