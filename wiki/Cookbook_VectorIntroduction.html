<div id="contentbox">
 <div class="widget">
  <p />
<h2>
  <a name="Introduction"> Introduction </a>
</h2>
<p />
Vectors are efficient data structures, containing a fixed number of elements that can be accessed in constant time, and in any order.  Vectors are mutable, though 'growing' a vector can be costly (as opposed to lists, which can grow at very little cost).
<p />
Vectors are printed in Scheme as a hash mark (<code>#</code>) followed by individual elements contained with a set of parenthesis.
<p />
<div class="scheme">
  <pre>(<span class="keyword">define</span> <span class="variable">test</span> (<span class="builtin">vector</span> <span class="selfeval">1</span> <span class="selfeval">#\a</span> <span class="selfeval">"dog"</span> <span class="selfeval">0.123</span> (<span class="builtin">/</span> <span class="selfeval">2</span> <span class="selfeval">3</span>)))
</pre>
</div>
<p />
Like lists, vectors can contain any mixture of types.  This ability allows vectors to be used to emulate object-oriented class-like mechanisms by storing functions as elements of the vector:
<p />
<div class="scheme">
  <pre><span class="builtin">&gt;</span> (<span class="keyword">define</span> <span class="variable">a</span> (<span class="builtin">vector</span> <span class="selfeval">1</span> <span class="keyword">'</span><span class="variable">a</span> <span class="selfeval">"dog"</span> <span class="selfeval">0.123</span> (<span class="keyword">lambda</span> (<span class="variable">x</span>) (<span class="builtin">+</span> <span class="selfeval">1</span> <span class="selfeval">2</span>))))
<span class="builtin">&gt;</span> <span class="variable">a</span>
<span class="selfeval">#</span>(<span class="selfeval">1</span> <span class="keyword">'</span><span class="variable">a</span> <span class="selfeval">"dog"</span> <span class="selfeval">0.123</span> (<span class="keyword">lambda</span> (<span class="variable">x</span>) (<span class="builtin">+</span> <span class="selfeval">1</span> <span class="selfeval">2</span>)))
<span class="builtin">&gt;</span> (<span class="builtin">vector-ref</span> <span class="variable">a</span> <span class="selfeval">2</span>)
<span class="selfeval">"dog"</span>
<span class="builtin">&gt;</span> ((<span class="builtin">eval</span> (<span class="builtin">vector-ref</span> <span class="variable">a</span> <span class="selfeval">4</span>)) <span class="selfeval">1</span>)
<span class="selfeval">3</span>
</pre>
</div>
<p />
<p />
The recipes in this section show various techniques to make the most of the vector data type.
<p />
<p />
<p />
-- <a href="/Main/BrentAFulgham">BrentAFulgham</a> - 21 Jan 2007
<p />
<h2>
  <a name="Notes"> Notes </a>
</h2>
<p />
Although #(1 2 3) evaluates to a vector in PLT Scheme, it is often better to use (vector 1 2 3).
The syntax #(1 2 3) indicates a literal constant, so it is an error to mutate the vector.
With (vector 1 2 3) the call to vector allocates a new vector, which it is ok to mutate.
Note also that in R5RS you need to quote vector constants, that is you need to write '#(1 2 3).
Finally normal vectors aren't "growable", but see for example the package "evector.plt"
at <a href="/Cookbook/PLaneT">PLaneT</a>, if you need a growable vector like data structure.
<p />
-- <a href="/Main/JensAxelSoegaard">JensAxelSoegaard</a> - 21 Jan 2007
  <p />
<table border="1" cellspacing="0" cellpadding="0">
   <tr>
  <th colspan="2" align="center" bgcolor="#99CCCC"> <a href="/Cookbook/CookbookForm">CookbookForm</a> </th>
</tr>
<tr>
  <th bgcolor="#99CCCC" align="right"> <a href="/Cookbook/TopicType">TopicType</a>:</th>
  <td align="left"> Section </td>
</tr>
<tr>
  <th bgcolor="#99CCCC" align="right"> <a href="/Cookbook/ParentTopic">ParentTopic</a>:</th>
  <td align="left"> <a href="/Cookbook/VectorChapter">VectorChapter</a> </td>
</tr>
<tr>
  <th bgcolor="#99CCCC" align="right"> <a href="/Cookbook/TopicOrder">TopicOrder</a>:</th>
  <td align="left"> 010 </td>
</tr>
</table>
<p />
 </div>
</div>
